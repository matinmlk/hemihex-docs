"use strict";(globalThis.webpackChunkhemihex_docs=globalThis.webpackChunkhemihex_docs||[]).push([[2458],{5248:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"Modeule/4-1 - API_for_GPIO_Library","title":"API for GPIO Library","description":"The Jetson GPIO library offers a comprehensive set of public APIs, mirroring those provided by the RPi.GPIO library. This document details the usage of each available API.","source":"@site/docs/04 - Modeule/4-1 - API_for_GPIO_Library.md","sourceDirName":"04 - Modeule","slug":"/Modeule/4-1 - API_for_GPIO_Library","permalink":"/docs/Modeule/4-1 - API_for_GPIO_Library","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/04 - Modeule/4-1 - API_for_GPIO_Library.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Linux Basics","permalink":"/docs/Linux Basics/linux-basics"},"next":{"title":"Jetson Orin nano Hardware Library Configuration","permalink":"/docs/Modeule/4-2 - Jetson_Orin_nano_Hardware_Library_Configuration"}}');var s=i(74848),l=i(28453);const a={},t="API for GPIO Library",c={},o=[{value:"1. Importing the Library",id:"1-importing-the-library",level:3},{value:"2. Pin Numbering",id:"2-pin-numbering",level:3},{value:"3. Warnings",id:"3-warnings",level:3},{value:"4. Setting Channels",id:"4-setting-channels",level:3},{value:"5. Input",id:"5-input",level:3},{value:"6. Output",id:"6-output",level:3},{value:"7. Cleanup",id:"7-cleanup",level:3},{value:"8. Jetson Module Information and Library Version",id:"8-jetson-module-information-and-library-version",level:3},{value:"9. Interrupts",id:"9-interrupts",level:3},{value:"<code>wait_for_edge()</code>",id:"wait_for_edge",level:4},{value:"<code>event_detected()</code>",id:"event_detected",level:4},{value:"Running a Callback Function on Edge Detection",id:"running-a-callback-function-on-edge-detection",level:4},{value:"10. Checking GPIO Channel Functionality",id:"10-checking-gpio-channel-functionality",level:3},{value:"11. Pulse Width Modulation (PWM)",id:"11-pulse-width-modulation-pwm",level:3}];function d(e){const n={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"api-for-gpio-library",children:"API for GPIO Library"})}),"\n",(0,s.jsx)(n.h1,{id:"api-for-gpio-library-1",children:"API for GPIO Library"}),"\n",(0,s.jsx)(n.p,{children:"The Jetson GPIO library offers a comprehensive set of public APIs, mirroring those provided by the RPi.GPIO library. This document details the usage of each available API."}),"\n",(0,s.jsx)(n.h3,{id:"1-importing-the-library",children:"1. Importing the Library"}),"\n",(0,s.jsx)(n.p,{children:"To integrate the Jetson.GPIO module into your application, use the following import statement:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import Jetson.GPIO as GPIO\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This allows you to reference the module simply as ",(0,s.jsx)(n.code,{children:"GPIO"})," throughout your code. For compatibility with existing RPi.GPIO applications, you can also import it using the ",(0,s.jsx)(n.code,{children:"RPi.GPIO"})," alias:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import RPi.GPIO as GPIO # Replaces Jetson.GPIO for existing RPi library code\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-pin-numbering",children:"2. Pin Numbering"}),"\n",(0,s.jsx)(n.p,{children:"The Jetson GPIO library supports four distinct methods for numbering IO pins. Two of these correspond to the modes found in the RPi.GPIO library:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"BOARD"}),": Refers to the physical pin numbers on the 40-pin GPIO connector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"BCM"}),": References the Broadcom SoC GPIO numbers."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The other two modes, specific to Jetson, utilize string-based identifiers:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CVM"}),": Corresponds to signal names on the CVM CVB connector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TEGRA_SOC"}),": Corresponds to signal names on the Tegra SoC."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You must explicitly set the desired pin numbering mode using one of the following calls:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.setmode(GPIO.BOARD)    # Use physical board pin numbers\r\n# or\r\nGPIO.setmode(GPIO.BCM)      # Use Broadcom SoC GPIO numbers\r\n# or\r\nGPIO.setmode(GPIO.CVM)      # Use CVM connector signal names\r\n# or\r\nGPIO.setmode(GPIO.TEGRA_SOC)# Use Tegra SoC signal names\n"})}),"\n",(0,s.jsx)(n.p,{children:"To verify the currently active mode, you can call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"mode = GPIO.getmode()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"mode"})," variable will return ",(0,s.jsx)(n.code,{children:"GPIO.BOARD"}),", ",(0,s.jsx)(n.code,{children:"GPIO.BCM"}),", ",(0,s.jsx)(n.code,{children:"GPIO.CVM"}),", ",(0,s.jsx)(n.code,{children:"GPIO.TEGRA_SOC"}),", or ",(0,s.jsx)(n.code,{children:"None"})," if no mode has been set."]}),"\n",(0,s.jsx)(n.h3,{id:"3-warnings",children:"3. Warnings"}),"\n",(0,s.jsx)(n.p,{children:"The library will issue a warning if a GPIO pin you attempt to configure is already in use by an external process, especially if the new configuration deviates from its default input state. Warnings will also be generated if you try to clean up channels before both the mode and channel have been set. To suppress these warnings, use:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.setwarnings(False)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-setting-channels",children:"4. Setting Channels"}),"\n",(0,s.jsx)(n.p,{children:"Before a GPIO channel can be used for input or output, it must first be configured."}),"\n",(0,s.jsx)(n.p,{children:"To configure a channel as an input:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.IN)\n"})}),"\n",(0,s.jsx)(n.p,{children:"To configure a channel as an output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.OUT)\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can also specify an initial output value when setting up the channel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Multiple channels can be configured simultaneously as output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"channels = [18, 12, 13]\r\nGPIO.setup(channels, GPIO.OUT)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-input",children:"5. Input"}),"\n",(0,s.jsx)(n.p,{children:"To read the current value of a configured input channel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.input(channel)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This function returns either ",(0,s.jsx)(n.code,{children:"GPIO.LOW"})," or ",(0,s.jsx)(n.code,{children:"GPIO.HIGH"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"6-output",children:"6. Output"}),"\n",(0,s.jsx)(n.p,{children:"To set the output state of a channel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.output(channel, state)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"state"})," parameter can be ",(0,s.jsx)(n.code,{children:"GPIO.LOW"})," or ",(0,s.jsx)(n.code,{children:"GPIO.HIGH"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"You can also apply an output state to a list or tuple of channels:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"channels = [18, 12, 13] # or use a tuple\r\nGPIO.output(channels, GPIO.HIGH) # Sets all specified channels to HIGH or GPIO.LOW\n"})}),"\n",(0,s.jsx)(n.p,{children:"To set different states for multiple channels in a sequence:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.output(channel_list_or_tuple, (GPIO.LOW, GPIO.HIGH, GPIO.HIGH)) # Example: Sets the first channel to LOW, the second and third to HIGH\n"})}),"\n",(0,s.jsx)(n.h3,{id:"7-cleanup",children:"7. Cleanup"}),"\n",(0,s.jsx)(n.p,{children:"It is good practice to reset all used GPIO pins to their default state at the end of your program. To clean up all channels that have been configured by the library:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.cleanup()\n"})}),"\n",(0,s.jsx)(n.p,{children:"If you prefer not to clear all channels, you can clean up specific individual channels or a list/tuple of channels:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.cleanup(chan1)              # Cleans up only 'chan1'\r\nGPIO.cleanup([chan1, chan2])     # Cleans up only 'chan1' and 'chan2'\r\nGPIO.cleanup((chan1, chan2))     # Performs the same operation as the list example\n"})}),"\n",(0,s.jsx)(n.h3,{id:"8-jetson-module-information-and-library-version",children:"8. Jetson Module Information and Library Version"}),"\n",(0,s.jsxs)(n.p,{children:["To retrieve information about the Jetson module, access the ",(0,s.jsx)(n.code,{children:"GPIO.JETSON_INFO"})," attribute:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"module_info = GPIO.JETSON_INFO\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This provides a Python dictionary containing keys such as ",(0,s.jsx)(n.code,{children:"P1_REVISION"}),", ",(0,s.jsx)(n.code,{children:"RAM"}),", ",(0,s.jsx)(n.code,{children:"REVISION"}),", ",(0,s.jsx)(n.code,{children:"TYPE"}),", ",(0,s.jsx)(n.code,{children:"MANUFACTURER"}),", and ",(0,s.jsx)(n.code,{children:"PROCESS"}),". All values in this dictionary are strings, with the exception of ",(0,s.jsx)(n.code,{children:"P1_REVISION"}),", which is an integer."]}),"\n",(0,s.jsxs)(n.p,{children:["To obtain the library version information, access ",(0,s.jsx)(n.code,{children:"GPIO.VERSION"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"library_version = GPIO.VERSION\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This attribute returns the library version as a string in ",(0,s.jsx)(n.code,{children:"XYZ"})," format."]}),"\n",(0,s.jsx)(n.h3,{id:"9-interrupts",children:"9. Interrupts"}),"\n",(0,s.jsx)(n.p,{children:"Beyond continuous polling, the library offers three methods for monitoring input events:"}),"\n",(0,s.jsx)(n.h4,{id:"wait_for_edge",children:(0,s.jsx)(n.code,{children:"wait_for_edge()"})}),"\n",(0,s.jsx)(n.p,{children:"This function halts the calling thread until a specified edge (rising, falling, or both) is detected on the given channel. It can be used as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.wait_for_edge(channel, GPIO.RISING)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The second parameter defines the edge to detect: ",(0,s.jsx)(n.code,{children:"GPIO.RISING"}),", ",(0,s.jsx)(n.code,{children:"GPIO.FALLING"}),", or ",(0,s.jsx)(n.code,{children:"GPIO.BOTH"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"You can also set an optional timeout for the waiting period (in milliseconds):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.wait_for_edge(channel, GPIO.RISING, timeout=500)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This function returns the channel number on which the edge was detected. If a timeout occurs before an edge is detected, it returns ",(0,s.jsx)(n.code,{children:"None"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"event_detected",children:(0,s.jsx)(n.code,{children:"event_detected()"})}),"\n",(0,s.jsx)(n.p,{children:"This function allows you to periodically check if any events have occurred on a channel since its last call. First, set up event detection for the channel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Set rising edge detection on the channel\r\nGPIO.add_event_detect(channel, GPIO.RISING)\r\n\r\n# Later in your code, to check for events:\r\nrun_other_code()\r\nif GPIO.event_detected(channel):\r\n    do_something()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As with ",(0,s.jsx)(n.code,{children:"wait_for_edge()"}),", you can detect ",(0,s.jsx)(n.code,{children:"GPIO.RISING"}),", ",(0,s.jsx)(n.code,{children:"GPIO.FALLING"}),", or ",(0,s.jsx)(n.code,{children:"GPIO.BOTH"})," edges."]}),"\n",(0,s.jsx)(n.h4,{id:"running-a-callback-function-on-edge-detection",children:"Running a Callback Function on Edge Detection"}),"\n",(0,s.jsx)(n.p,{children:"This feature enables a secondary thread to execute a callback function concurrently with your main program when an edge is detected. This allows for asynchronous handling of GPIO events. Here's how to use it:"}),"\n",(0,s.jsx)(n.p,{children:"First, define your callback function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def callback_fn(channel):\r\n    print("Callback called from channel %s" % channel)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Then, add event detection to the channel, specifying your callback function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Add rising edge detection with a callback\r\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn)\n"})}),"\n",(0,s.jsx)(n.p,{children:"If necessary, you can also specify a debounce time."}),"\n",(0,s.jsx)(n.h1,{id:"api-for-gpio-library-2",children:"API for GPIO Library"}),"\n",(0,s.jsx)(n.p,{children:"Multiple callback functions can also be assigned if necessary:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def callback_one(channel):\r\n    print("First Callback")\r\n\r\ndef callback_two(channel):\r\n    print("Second Callback")\r\n\r\nGPIO.add_event_detect(channel, GPIO.RISING)\r\nGPIO.add_event_callback(channel, callback_one)\r\nGPIO.add_event_callback(channel, callback_two)\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this scenario, these two callback functions will execute sequentially rather than concurrently, as a single thread handles all callback operations."}),"\n",(0,s.jsxs)(n.p,{children:["To prevent a single event from triggering callback functions multiple times (e.g., due to switch bounce), you can set a ",(0,s.jsx)(n.code,{children:"bouncetime"}),". This parameter, specified in milliseconds, helps to consolidate closely spaced events into a single detection:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# bouncetime is set in milliseconds\r\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn, bouncetime=200)\n"})}),"\n",(0,s.jsx)(n.p,{children:"If edge detection is no longer required for a channel, it can be disabled as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.remove_event_detect(channel)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"10-checking-gpio-channel-functionality",children:"10. Checking GPIO Channel Functionality"}),"\n",(0,s.jsx)(n.p,{children:"This feature enables you to query the current operational mode of a given GPIO channel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"GPIO.gpio_function(channel)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This function will return either ",(0,s.jsx)(n.code,{children:"GPIO.IN"})," (indicating an input channel) or ",(0,s.jsx)(n.code,{children:"GPIO.OUT"})," (indicating an output channel)."]}),"\n",(0,s.jsx)(n.h3,{id:"11-pulse-width-modulation-pwm",children:"11. Pulse Width Modulation (PWM)"}),"\n",(0,s.jsxs)(n.p,{children:["For detailed guidance on utilizing PWM channels, please refer to the ",(0,s.jsx)(n.code,{children:"samples/simple_PWM.py"})," example."]}),"\n",(0,s.jsx)(n.p,{children:"It is crucial to note that this GPIO library provides PWM support exclusively for pins that incorporate hardware PWM controllers. Unlike some other GPIO libraries, this library does not implement software-simulated PWM."}),"\n",(0,s.jsx)(n.p,{children:"Proper configuration of the system's pin multiplexer is essential to connect the hardware PWM controller to the relevant pins. If the pinmux is not configured correctly, the PWM signal will not reach the physical pin. This GPIO library does not dynamically alter pinmux configurations to achieve this. Please consult the L4T documentation for comprehensive information on configuring the pin multiplexer."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var r=i(96540);const s={},l=r.createContext(s);function a(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);