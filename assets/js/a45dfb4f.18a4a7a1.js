"use strict";(globalThis.webpackChunkhemihex_docs=globalThis.webpackChunkhemihex_docs||[]).push([[2229],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(96540);const a={},l=i.createContext(a);function o(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(l.Provider,{value:n},e.children)}},62660:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"HH-101/Online AI Model/Multimodal-Table-Scanning-Application-v2","title":"Multimodal table scanning application-10","description":"1. Concept Introduction","source":"@site/docs/hh101/HH-101/12 - Online AI Model/10-Multimodal-Table-Scanning-Application-v2.md","sourceDirName":"HH-101/12 - Online AI Model","slug":"/HH-101/Online AI Model/Multimodal-Table-Scanning-Application-v2","permalink":"/hh-101/HH-101/Online AI Model/Multimodal-Table-Scanning-Application-v2","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Multimodal table scanning application-10","sidebar_position":10},"sidebar":"hh101Sidebar","previous":{"title":"Multi module visual position application","permalink":"/hh-101/HH-101/Online AI Model/Multi-Module-Visual-Position-Application"},"next":{"title":"Multimodal autonomous proxy application-11","permalink":"/hh-101/HH-101/Online AI Model/Multimodal-Autonomous-Proxy-Application-v2"}}');var a=t(74848),l=t(28453);const o={title:"Multimodal table scanning application-10",sidebar_position:10},r="6.Multimodal table scanning application",s={},c=[{value:"1. Concept Introduction",id:"1-concept-introduction",level:2},{value:"1.1 What is &quot;Multimodal Table Scanning&quot;?",id:"11-what-is-multimodal-table-scanning",level:3},{value:"1.2 Implementation Principles",id:"12-implementation-principles",level:3},{value:"2. Code Analysis",id:"2-code-analysis",level:2},{value:"Key Code",id:"key-code",level:3},{value:"1. Tools Layer Entry ( largemodel/utils/tools_manager.py )",id:"1-tools-layer-entry--largemodelutilstools_managerpy-",level:4},{value:"2. Model interface layer ( largemodel/utils/large_model_interface.py )",id:"2-model-interface-layer--largemodelutilslarge_model_interfacepy-",level:4},{value:"Code Analysis",id:"code-analysis",level:3},{value:"3. Practical Application",id:"3-practical-application",level:2},{value:"3.1 Configuring Online LLM",id:"31-configuring-online-llm",level:3},{value:"3.2 Launch and test the function",id:"32-launch-and-test-the-function",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"6multimodal-table-scanning-application",children:"6.Multimodal table scanning application"})}),"\n",(0,a.jsx)(n.h2,{id:"1-concept-introduction",children:"1. Concept Introduction"}),"\n",(0,a.jsx)(n.h3,{id:"11-what-is-multimodal-table-scanning",children:'1.1 What is "Multimodal Table Scanning"?'}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multimodal table scanning"})," is a technology that uses image processing and artificial intelligence to identify and extract table information from images or PDF documents. It not only focuses on visual table structure recognition but also integrates multimodal data such as text content and layout information to enhance table understanding. ",(0,a.jsx)(n.strong,{children:"Large Language Models (LLMs)"})," provide powerful semantic analysis capabilities to understand this extracted information. The two complement each other and enhance the intelligent level of document processing."]}),"\n",(0,a.jsx)(n.h3,{id:"12-implementation-principles",children:"1.2 Implementation Principles"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Table Detection and Content Recognition"})}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Utilizes computer vision technology to locate tables in documents and uses optical character recognition (OCR) technology to convert the text within the tables into an editable format."}),"\n",(0,a.jsx)(n.li,{children:"Utilizes deep learning methods to analyze the table structure (row and column division, cell merging, etc.) and generate a structured data representation."}),"\n"]}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Multimodal Fusion"})}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Integrate visual information (such as table layout), text (OCR results), and any metadata (such as file type and source) to form a comprehensive view of the data."}),"\n",(0,a.jsx)(n.li,{children:"Use a specially designed multimodal model (such as LayoutLM) to simultaneously process these different types of data to more accurately understand the table content and its context."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"2-code-analysis",children:"2. Code Analysis"}),"\n",(0,a.jsx)(n.h3,{id:"key-code",children:"Key Code"}),"\n",(0,a.jsx)(n.h4,{id:"1-tools-layer-entry--largemodelutilstools_managerpy-",children:"1. Tools Layer Entry ( largemodel/utils/tools_manager.py )"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"scan_table"})," function in this file defines the tool's execution flow, specifically how it constructs a prompt that returns a Markdown-formatted result."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# From largemodel/utils/tools_manager.py\nclass ToolsManager:\n    # ...\n    def scan_table(self, args):\n        """\n        Scan a table from an image and save the content as a Markdown file.\n\n        :param args: Arguments containing the image path.\n        :return: Dictionary with file path and content.\n        """\n        self.node.get_logger().info(f"Executing scan_table() tool with args: {args}")\n        try:\n            image_path = args.get("image_path")\n            # ... (Path checking and fallback)\n\n            # Construct a prompt asking the large model to recognize the table and return it in Markdown format.\n            if self.node.language == \'zh\':\n                prompt = "Please carefully analyze this image, identify the table within it, and return its content in Markdown format.  # translated from Chinese"\n            else:\n                prompt = "Please carefully analyze this image, identify the table within it, and return its content in Markdown format."\n\n            result = self.node.model_client.infer_with_image(image_path, prompt)\n\n            # ... (Extract Markdown text from the results)\n\n            # Save the recognized content to a Markdown file.\n            md_file_path = os.path.join(self.node.pkg_path, "resources_file", "scanned_tables", f"table_{timestamp}.md")\n            with open(md_file_path, \'w\', encoding=\'utf-8\') as f:\n                f.write(table_content)\n\n            return {\n                "file_path": md_file_path,\n                "table_content": table_content\n            }\n        # ... (Error Handling)\n'})}),"\n",(0,a.jsx)(n.h4,{id:"2-model-interface-layer--largemodelutilslarge_model_interfacepy-",children:"2. Model interface layer ( largemodel/utils/large_model_interface.py )"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"infer_with_image"})," function in this file is the unified entry point for all image-related tasks."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# From largemodel/utils/large_model_interface.py\n\nclass model_interface:\n    # ...\n    def infer_with_image(self, image_path, text=None, message=None):\n        \"\"\"Unified image inference interface.\"\"\"\n        # ... (Prepare message)\n        try:\n            # Determine which specific implementation to call based on the value of self.llm_platform\n            if self.llm_platform == 'ollama':\n                response_content = self.ollama_infer(self.messages, image_path=image_path)\n            elif self.llm_platform == 'tongyi':\n                # ... Logic for calling the Tongyi model\n                pass\n            # ... (Logic for other platforms)\n        # ...\n        return {'response': response_content, 'messages': self.messages.copy()}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"code-analysis",children:"Code Analysis"}),"\n",(0,a.jsxs)(n.p,{children:["The table scanning function is a typical application for converting unstructured image data into structured text data. Its core technology remains ",(0,a.jsx)(n.strong,{children:"guiding model behavior through prompt engineering"}),"."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Tools Layer (tools_manager.py)"}),":"]}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"scan_table"})," function is the business process controller for this function. It receives an image containing a table as input."]}),"\n",(0,a.jsxs)(n.li,{children:["The key operation of this function is ",(0,a.jsx)(n.strong,{children:"building a targeted prompt"})," . This prompt directly instructs the large model to perform two tasks: 1. Recognize the table in the image. 2. Return the recognized content in Markdown format. This mandatory output format is key to achieving unstructured-to-structured conversion."]}),"\n",(0,a.jsxs)(n.li,{children:["After constructing the prompt, it calls the ",(0,a.jsx)(n.code,{children:"infer_with_image"})," method of the model interface layer, passing the image and the formatting instructions."]}),"\n",(0,a.jsxs)(n.li,{children:["After receiving the Markdown text returned from the model interface layer, it performs a file operation: writing the text content to a new ",(0,a.jsx)(n.code,{children:".md"})," file."]}),"\n",(0,a.jsx)(n.li,{children:"Finally, it returns structured data containing the new file path and table contents."}),"\n"]}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Model Interface Layer (large_model_interface.py)"}),":"]}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"infer_with_image"}),' function continues to serve as the unified "dispatching center." It receives the image and prompt from ',(0,a.jsx)(n.code,{children:"scan_table"})," and dispatches the task to the correct backend model implementation based on the current system configuration ( ",(0,a.jsx)(n.code,{children:"self.llm_platform"})," )."]}),"\n",(0,a.jsx)(n.li,{children:"Regardless of the backend model, this layer handles the communication details with the specific platform, ensuring that the image and text data are sent correctly, and then returns the plain text (in this case, Markdown-formatted text) returned by the model to the tooling layer."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In summary, the general workflow for table scanning is: ToolsManager receives an image and constructs a command to convert the table in this image to Markdown. ToolsManager calls the model interface. ModelInterface packages the image and the command and sends them to the corresponding model platform according to the configuration. The model returns Markdown-formatted text. ModelInterface returns the text to ToolsManager. ToolsManager saves the text as a .md file and returns the result. This workflow demonstrates how to leverage the formatting capabilities of the large model as a powerful OCR (Optical Character Recognition) and data structuring tool."}),"\n",(0,a.jsx)(n.h2,{id:"3-practical-application",children:"3. Practical Application"}),"\n",(0,a.jsx)(n.h3,{id:"31-configuring-online-llm",children:"3.1 Configuring Online LLM"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"First, obtain the API key from any of the platforms described in the previous tutorials."})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Next, you need to update the key in the configuration file. Open the model interface configuration file large_model_interface.yaml"}),": xxxxxxxxxxvim ~/hemihex_ws/src/largemodel/config/large_model_interface.yaml"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Enter your API Key"}),':\nFind the corresponding section and paste the API Key you just copied. This example uses the Tongyi Qianwen configuration. xxxxxxxxxx# large_model_interface.yaml## Thousand Questions on Tongyiqianwen_api_key: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" # Paste your Keyqianwen_model: "qwen-vl-max-latest" # You can choose the model as needed, such asqwen-turbo, qwen-plus']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Open the main configuration file HemiHex.yaml"}),": xxxxxxxxxxvim ~/hemihex_ws/src/largemodel/config/HemiHex.yaml"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Select the online platform you want to use"}),":\nChange the ",(0,a.jsx)(n.code,{children:"llm_platform"})," parameter to the platform name you want to use. xxxxxxxxxx# HemiHex.yamlmodel_service:  ros__parameters:    # ...    llm_platform: 'tongyi'  #Optional platforms:'ollama', 'tongyi', 'spark', 'qianfan', 'openrouter'"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"32-launch-and-test-the-function",children:"3.2 Launch and test the function"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prepare the image file"}),": Place the image file to be tested in the following directory:",(0,a.jsx)(n.code,{children:"/home/jetson/hemihex_ws/src/largemodel/resources_file/scan_table"})," Then name the image ",(0,a.jsx)(n.code,{children:"test_table.jpg"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Start the largemodel main program"}),": Open a terminal and run the following command: xxxxxxxxxxros2 launch largemodel largemodel_control.launch.py"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Test"}),":"]}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Wake up"}),': Say "Hi,HemiHex" into the microphone.']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dialogue"}),': After the speaker responds, you can say, "Analyze the table."']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Observe the log"}),": In the terminal running the ",(0,a.jsx)(n.code,{children:"launch"})," file, you should see the following:","\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The ASR node recognizes your question and prints it."}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"model_service"})," node receives the text, calls the LLM, and prints the LLM's response."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Listen for the answer"}),": After a while, you should hear the answer from the speaker and find an md file containing the table information in the ",(0,a.jsx)(n.code,{children:"/home/jetson/hemihex_ws/src/largemodel/resources_file/scan_table"})," path."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);