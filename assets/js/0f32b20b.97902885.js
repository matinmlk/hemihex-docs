"use strict";(globalThis.webpackChunkhemihex_docs=globalThis.webpackChunkhemihex_docs||[]).push([[7684],{24853:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"HH-101/Online AI Model/Multimodal-Visual-Localization-Application","title":"Multimodal visual localization application","description":"1. Concept Introduction","source":"@site/docs/hh101/HH-101/12 - Online AI Model/03-Multimodal-Visual-Localization-Application.md","sourceDirName":"HH-101/12 - Online AI Model","slug":"/HH-101/Online AI Model/Multimodal-Visual-Localization-Application","permalink":"/hh-101/HH-101/Online AI Model/Multimodal-Visual-Localization-Application","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Multimodal visual localization application","sidebar_position":3},"sidebar":"hh101Sidebar","previous":{"title":"OpenRouter Large Model API Aggregation Platform","permalink":"/hh-101/HH-101/Online AI Model/openrouter-api-aggregation-platform-12-onlineaimodel-12-1"},"next":{"title":"Multimodal table scanning application","permalink":"/hh-101/HH-101/Online AI Model/Multimodal-Table-Scanning-Application"}}');var a=t(74848),o=t(28453);const l={title:"Multimodal visual localization application",sidebar_position:3},s="3.Multimodal visual localization application",r={},c=[{value:"1. Concept Introduction",id:"1-concept-introduction",level:2},{value:"1.1 What is &quot;Multimodal Visual Localization&quot;?",id:"11-what-is-multimodal-visual-localization",level:3},{value:"1.2 Brief Overview of Implementation Principles",id:"12-brief-overview-of-implementation-principles",level:3},{value:"2. Code Analysis",id:"2-code-analysis",level:2},{value:"Key Code",id:"key-code",level:3},{value:"1. Tools Layer Entry (largemodel/utils/tools_manager.py)",id:"1-tools-layer-entry-largemodelutilstools_managerpy",level:4},{value:"2. Model interface layer (largemodel/utils/large_model_interface.py)",id:"2-model-interface-layer-largemodelutilslarge_model_interfacepy",level:4},{value:"Code Analysis",id:"code-analysis",level:3},{value:"3. Practical Application",id:"3-practical-application",level:2},{value:"3.1 Configuring Online LLM",id:"31-configuring-online-llm",level:3},{value:"3.2 Starting and Testing the Function",id:"32-starting-and-testing-the-function",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"3multimodal-visual-localization-application",children:"3.Multimodal visual localization application"})}),"\n",(0,a.jsx)(n.h2,{id:"1-concept-introduction",children:"1. Concept Introduction"}),"\n",(0,a.jsx)(n.h3,{id:"11-what-is-multimodal-visual-localization",children:'1.1 What is "Multimodal Visual Localization"?'}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multimodal visual localization"}),"is a technology that combines multiple sensor inputs (such as cameras, depth sensors, and IMUs) with algorithmic processing techniques to accurately identify and track the position and posture of a device or user in an environment. This technology does not rely solely on a single type of sensor data, but instead integrates information from different perception modalities, thereby improving localization accuracy and robustness."]}),"\n",(0,a.jsx)(n.h3,{id:"12-brief-overview-of-implementation-principles",children:"1.2 Brief Overview of Implementation Principles"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Cross-modal Representation Learning : In order for LLMs to be capable of processing visual information, a mechanism must be developed to transform visual signals into a form that the model can understand. This may involve extracting features using convolutional neural networks (CNNs) or other architectures suitable for image processing and mapping them into the same embedding space as text."}),"\n",(0,a.jsx)(n.li,{children:"Joint Training : By designing an appropriate loss function, text and visual data can be trained simultaneously within the same framework, allowing the model to learn to relate to these two modalities. For example, in a question-answering system, answers can be given based on both the provided text question and the associated image content."}),"\n",(0,a.jsx)(n.li,{children:"Visually Guided Language Generation/Understanding : Once effective cross-modal representations are established, visual information can be leveraged to enhance the capabilities of the language model. For example, when given a photo, the model can not only describe what is happening in the image, but also answer specific questions about the scene and even execute instructions based on visual cues (such as navigating to a location)."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"2-code-analysis",children:"2. Code Analysis"}),"\n",(0,a.jsx)(n.h3,{id:"key-code",children:"Key Code"}),"\n",(0,a.jsx)(n.h4,{id:"1-tools-layer-entry-largemodelutilstools_managerpy",children:"1. Tools Layer Entry (largemodel/utils/tools_manager.py)"}),"\n",(0,a.jsxs)(n.p,{children:["The",(0,a.jsx)(n.code,{children:"visual_positioning"}),"function in this file defines the execution flow of the tool, specifically how it constructs a prompt containing the target object name and formatting requirements."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# From largemodel/utils/tools_manager.py\nclass ToolsManager:\n# ...\ndef visual_positioning(self, args):\n"""\nLocate object coordinates in image and save results to MD file.\n\n:param args: Arguments containing image path and object name.\n:return: Dictionary with file path and coordinate data.\n"""\nself.node.get_logger().info(f"Executing visual_positioning() tool with args: {args}")\ntry:\nimage_path = args.get("image_path")\nobject_name = args.get("object_name")\n# ... (path fallback mechanism and parameter checking)\n\n# Construct a prompt asking the large model to identify the coordinates of the specified object.\nif self.node.language == \'zh\':\nprompt = f"Carefully analyze this image and locate each [object_name]. Return bounding box coordinates in the required format."  # translated from Chinese\nelse:\nprompt = f"Please carefully analyze this image and find the position of all [object_name]..."\n\n# ... (Build an independent message context)\n\nresult = self.node.model_client.infer_with_image(image_path, prompt, message=message_to_use)\n\n# ... (Process and parse the returned coordinate text)\n\nreturn {\n"file_path": md_file_path,\n"coordinates_content": coordinates_content,\n"explanation_content": explanation_content\n}\n# ... (error handling)\n'})}),"\n",(0,a.jsx)(n.h4,{id:"2-model-interface-layer-largemodelutilslarge_model_interfacepy",children:"2. Model interface layer (largemodel/utils/large_model_interface.py)"}),"\n",(0,a.jsxs)(n.p,{children:["The",(0,a.jsx)(n.code,{children:"infer_with_image"}),"function in this file is the unified entry point for all image-related tasks."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# From largemodel/utils/large_model_interface.py\n\nclass model_interface:\n# ...\ndef infer_with_image(self, image_path, text=None, message=None):\n\"\"\"Unified image inference interface. \"\"\"\n# ... (Prepare message)\ntry:\n# Determine which specific implementation to call based on the value of self.llm_platform\nif self.llm_platform == 'ollama':\nresponse_content = self.ollama_infer(self.messages, image_path=image_path)\nelif self.llm_platform == 'tongyi':\n# ... Calling the logic of the Tongyi model\npass\n# ... (Logic for other platforms)\n# ...\nreturn {'response': response_content, 'messages': self.messages.copy()}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"code-analysis",children:"Code Analysis"}),"\n",(0,a.jsxs)(n.p,{children:["The core of the visual positioning function lies in",(0,a.jsx)(n.strong,{children:"guiding large models to output structured data through precise instructions"}),". It also follows the layered design of the tool layer and the model interface layer."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Tools Layer ( tools_manager.py ): The visual_positioning function is the core of this function. It accepts two key parameters: image_path (the image path) and object_name (the name of the object to be positioned). The core operation of this function is building a highly customized prompt . It doesn't simply ask the model to describe an image. Instead, it embeds object_name into a carefully designed template, explicitly instructing the model to \"locate each [object_name] in the image,\" and implicitly or explicitly requires the results to be returned in a specific format (such as an array of coordinates). After building the prompt, it calls the infer_with_image method of the model interface layer, passing the image and this customized instruction. * After receiving the returned text from the model interface layer, it needs to perform post-processing : using methods such as regular expressions to parse the model's natural language response to extract precise coordinate data. Finally, it returns the parsed structured coordinate data to the upper-layer application."}),"\n",(0,a.jsx)(n.li,{children:'Model Interface Layer ( large_model_interface.py ) : The infer_with_image function still serves as the "dispatching center." It receives the image and prompt from visual_positioning and dispatches the task to the correct backend model implementation based on the current configuration ( self.llm_platform ). For visual positioning tasks, the model interface layer\'s responsibilities are essentially the same as for visual understanding tasks: correctly packaging the image data and text instructions, sending them to the selected model platform, and then returning the returned text results intact to the tool layer. All platform-specific implementation details are encapsulated in this layer.'}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In summary, the general workflow for visual localization is: ToolsManager receives the target object name and constructs a precise prompt requesting coordinates. ToolsManager calls the model interface. ModelInterface packages the image and prompt together and sends them to the corresponding model platform according to the configuration. The model returns a text file containing the coordinates. ModelInterface returns this text file to ToolsManager. ToolsManager parses the text file, extracts the structured coordinate data, and returns it. This process demonstrates how Prompt Engineering can be used to enable a general large-scale visual model to accomplish more specific and structured tasks."}),"\n",(0,a.jsx)(n.h2,{id:"3-practical-application",children:"3. Practical Application"}),"\n",(0,a.jsx)(n.h3,{id:"31-configuring-online-llm",children:"3.1 Configuring Online LLM"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"First, obtain the API key from any platform described in the previous tutorial."}),"\n",(0,a.jsx)(n.li,{children:"Next, update the key in the configuration file. Open the model interface configuration file, large_model_interface.yaml : xxxxxxxxxx vim ~/hemihex_ws/src/largemodel/config/large_model_interface.yaml"}),"\n",(0,a.jsx)(n.li,{children:'Enter your API Key : Find the corresponding section and paste the API Key you just copied. This example uses the Tongyi Qianwen configuration. xxxxxxxxxx # large_model_interface.yaml  ## Thousand Questions on Tongyi qianwen_api_key : "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" # Paste your Key qianwen_model : "qwen-vl-max-latest" # You can choose the model as needed, such asqwen-turbo, qwen-plus'}),"\n",(0,a.jsx)(n.li,{children:"Open the main configuration file HemiHex.yaml : xxxxxxxxxx vim ~/hemihex_ws/src/largemodel/config/HemiHex.yaml"}),"\n",(0,a.jsx)(n.li,{children:"Select the online platform you want to use : Change the llm_platform parameter to the platform name you want to use. xxxxxxxxxx # HemiHex.yaml  model_service : ros__parameters : # ... llm_platform : 'tongyi' #Optional platforms: 'ollama', 'tongyi', 'spark', 'qianfan', 'openrouter'"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"32-starting-and-testing-the-function",children:"3.2 Starting and Testing the Function"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Prepare the image file :"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Place the image file to be tested in the following path:",(0,a.jsx)(n.code,{children:"/home/jetson/hemihex_ws/src/largemodel/resources_file/visual_positioning"})]}),"\n",(0,a.jsxs)(n.p,{children:["Then name the image",(0,a.jsx)(n.code,{children:"test_image.jpg"})]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Start the largemodel main program :"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Open a terminal and run the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"ros2 launch largemodel largemodel_control.launch.py text_chat_mode:=true\n"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Send a text command : Open another terminal and run the following command:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 run text_chat text_chat\n"})}),"\n",(0,a.jsx)(n.p,{children:'Then start typing: "Analyze the position of the dinosaur in the image."'}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Observe the results : In the first terminal running the main program, you will see log output indicating that the system received the command, called the visual_positioning tool, completed the execution, and saved the coordinates to a file."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This file can be found in the ~/hemihex_ws/src/largemodel/resources_file/visual_positioning directory."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var i=t(96540);const a={},o=i.createContext(a);function l(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);